12-4:
依赖应该与 pom.xml 的 properties 同一个等级

为什么要叫 entity？因为这两个类是用来承载数据的实体对象

今日的任务：只要能看到客户端发出的 RpcRequest 对象在服务端控制台打印出来就算成功
具体实现需要分三步走
1. 让 rpc-core 认识 rpc-common
2. 编写服务端：在 rpc-core 里写一个能“听懂” Java 对象的 Netty 服务端。
3. 编写客户端：在 rpc-core (或者 test-client) 里写一个能“发送” Java 对象的 Netty 客户端。

第一步：打通模块依赖 (Module Dependencies)
你的 RpcRequest 在 rpc-common 模块里，而你的 Netty 代码在 rpc-core 里。 所以，你需要告诉 Maven：rpc-core 依赖 rpc-common。

第二步：编写服务端 (RpcServer)
我们在 rpc-core 模块下，新建包 com.github.spock12138.rpc.core.server，然后新建类 RpcServer。

总结 ---- 按照你的一步步操作，我已经实现了客户端和服务器端的通信。今天关于搭建 rpc 项目，包括创建项目框架，实现基础的客户端发出的对象，服务器端可以成功打印出来。创建的entity类包括 RpcRequest 与 rpcResponse，core 中创建了client 与 server 包，创建了 客户类与服务器类。


一、 服务端代码翻译 (RpcServer)
把服务端想象成一个繁忙的银行网点。
1. 两个线程组 (EventLoopGroup)
bossGroup（大堂经理）： 他只做一件事——站在门口**“迎宾”**（处理 accept 事件）。客人进门了，他就把客人领给柜台。
workerGroup（柜台职员）： 他们负责**“干活”**（处理 read/write 事件）。比如存钱、取钱、打印流水。
为什么分两个？ 为了效率。大堂经理不干杂活，专心迎宾，这样门口就不会排长队。
2. 启动助手 (ServerBootstrap)
这是一个配置单。因为 Netty 的组件太多了，用这个助手类来把所有的组件组装起来。
3. 流水线 (Pipeline & Handler) —— 全场核心
想象一条传送带。网络传过来的原本是 010101 这种字节流（包裹）。
ObjectDecoder（拆包员）： 把包裹拆开，把字节流变成一个 Java 对象（RpcRequest）。
SimpleChannelInboundHandler（业务员）： 拿到已经是对象的 RpcRequest，看里面的内容（打印日志）。
顺序至关重要： 必须先拆包（Decoder），业务员才能看懂。如果顺序反了，业务员拿到的就是一堆乱码。

二、 客户端代码翻译 (RpcClient)  --  寄快递
1. 启动与连接
客户端只需要一个线程组（因为不需要分工），负责拨打电话连接服务器。
2. 发送数据 (writeAndFlush)
Write（写）： 把信放到邮箱里。
Flush（冲刷）： 举起邮箱的小旗子，告诉邮递员“赶紧把信拿走发出去”。（如果不 Flush，数据可能会积压在本地缓冲发不出去）。
经过 Pipeline： 你的 RpcRequest 对象，会先经过 ObjectEncoder（打包员），被转化成字节流，然后通过网线发出去。

三、 总结：Netty 的“三板斧”
以后不管怎么改代码，核心逻辑永远是这三步：
老板与工人（Group）： 负责线程调度。
传送带（Pipeline）： 数据进来该怎么处理？（解码 -> 业务 -> 编码）。
大喇叭（ChannelHandler）： 具体的业务逻辑全写在这里（比如今天的打印日志，明天的调用服务）。


12-5:
遇到这个错误  Cannot resolve symbol 'HelloService'
test-server 模块根本不知道 rpc-api 模块的存在
虽然你在同一个项目里写了这两个模块，但在 Maven 的世界里，如果不在 pom.xml 里明确声明依赖，它们就是两个陌生人。
你需要去 test-server 模块的 pom.xml 里“介绍”它们认识。
解决方法
请打开 test-server 模块下的 pom.xml 文件，添加如下依赖代码

注意导包 (Imports) 鼠标放在红字上，按 Alt + Enter（或者 Option + Enter），选择 Import Class。

今天的总结复盘
一、 今天你到底学会了什么？（核心复盘）
1. 架构观：Maven 的“模块社交学”
遇到的坑： 你在写 HelloServiceImpl 时报错找不到 HelloService，这是新手最容易卡壳的地方。
学到的点： Maven 模块隔离。
默认情况下，test-server 根本不认识 rpc-api。你必须在 pom.xml 里显式添加 <dependency>，就像给两个陌生人发名片介绍认识一样。这是大型 Java 项目的标准管理方式。
2. 通信观：Netty 的“流水线思维”
代码体现： 你在 RpcClient 和 RpcServer 里写的 pipeline.addLast(...)。
学到的点： 责任链模式。
数据在网络传输时是 0/1 比特流。
解码器 (Decoder)：负责把“比特流”变成“Java 对象”（拆快递）。
业务 Handler：负责处理对象（看信件内容、回信）。
编码器 (Encoder)：负责把“Java 对象”变回“比特流”（打包发走）。
这种分工让代码非常清晰，以后你想换加密方式，只改编解码器就行，不用动业务逻辑。
3. 核心技：反射 (Reflection) 的“上帝视角”
代码体现： Server 端那几行 method.invoke(...)。
学到的点： 动态代理的基石。
普通的 Java 调用是写死的（service.sayHello()）。
RPC 的调用是动态的：“给我一个字符串 'sayHello'，我就能让它跑起来”。这就是框架和业务代码的区别——框架可以在不知道具体写了什么方法的情况下，去驱动业务代码运行。
二、 你的 RPC 运行全流程（脑内动画）
闭上眼睛，回想一下你刚才启动的那两个黑窗口，它们背后发生了这件事：
启动 (Server Start)： TestServer 启动，把一张“菜单”（HelloServiceImpl）交给了 RpcServer 保管（注册表 Map）。
打包 (Client Send)： RpcClient 启动，把你写的“我想调用 sayHello”这句话，封装进 RpcRequest 盒子，贴上快递单，通过 Netty 发出去。
解析与执行 (Server Work)：
Server 收到盒子，打开一看：“哦，要找 HelloService 的 sayHello 方法”。
Server 去查注册表，找到对应的对象。
Server 用 反射 手段，强行让那个对象执行了方法。
回信 (Response)： Server 把执行结果 “你好, Spock!” 装进 RpcResponse 盒子，原路发回。
收货 (Client Receive)： Client 收到盒子，拆开，打印在控制台上。

关于反射的总结
普通调用： obj.method()。像是按按钮。按钮是固定的，按这个按钮只能亮这盏灯。
反射调用： method.invoke(obj)。像是声控智能家居。你喊“开灯”，它解析你的指令去开灯；你喊“放音乐”，它解析指令去放音乐。RPC Server 就是那个听指令的智能音箱。



12-8:
今天的任务安排 ---- 把 Client 端的代码，用 动态代理 (Dynamic Proxy) 包装起来。让它看起来像在调用本地方法一样简单：helloService.sayHello("Spock")。

第一个遇到的就是梯子问题，设置在 IDEA 中设置 Git 代理
git config --global http.proxy http://127.0.0.1:7890
git config --global https.proxy http://127.0.0.1:7890
重试 Push：如果你以后关了代理软件，Git 可能会报错连不上。到时候在 Terminal 输入 git config --global --unset http.proxy 和 git config --global --unset https.proxy 取消设置即可。


核心概念：什么是“代理 (Proxy)”？
普通调用： 你直接给明星（Server）打电话。但明星在另一个城市（另一台电脑），你够不着。

代理模式： 你找明星的经纪人（Proxy）。
经纪人手里有一张和明星一模一样的名片（接口 Interface）。
你对经纪人说：“我要找明星唱歌（调用 sayHello）”。
经纪人说：“好，我帮你传达。”
经纪人默默地把你的请求写在纸上（封装 RpcRequest），寄给明星，等明星回信，然后再把结果告诉你。
你今天要写的 ClientProxy 就是这个经纪人。

第一步：改造 RpcClient (让它变成单纯的送信员)
昨天你的 RpcClient 里，RpcRequest 是硬编码写死的（Spock, sayHello）。 我们要把它改造成：给它什么信，它就送什么信。
修改 rpc-core 下的 RpcClient.java

第二步：创建动态代理类 (ClientProxy) —— 今天的核心
在 rpc-core 模块下，新建包 com.github.spock12138.rpc.core.proxy，新建类 ClientProxy

第三步：见证“本地调用”的时刻
我们去 test-client 模块，修改测试类 TestClient (或者你之前的 main 方法)。


你的“今日任务”清单
改造 RpcClient：把 request 改成参数传入。
新建 ClientProxy：复制上面的代码，理解 invoke 方法是怎么偷天换日的。
运行测试：
先启动 TestServer。
再启动新的 TestClient。
预期结果： 你虽然在 Client 端代码里只写了 helloService.sayHello(...)，但 Server 端应该能收到请求，并且 Client 端控制台会打印出 Server 发回来的响应。

今天学习包括的知识点 JDK 动态代理 + Netty 异步调用 + 反射

三、 完整的数据流向动画
当你执行 helloService.sayHello("Spock-Proxy") 时，数据是这样流动的：
TestClient 发起调用。
JDK 动态代理 捕获调用，直接跳转到 ClientProxy.invoke()。
ClientProxy 把 "sayHello" 和 "Spock-Proxy" 两个词，打包进 RpcRequest 对象。
ClientProxy 把 RpcRequest 对象递给 RpcClient。
RpcClient 通过 Netty 把对象发给 服务端。
(服务端处理...)
RpcClient 的 Handler 收到回信 "你好..."，并打印在控制台上。

明天的主线： 我们要让 TestClient 能真正拿到返回值，而不是去控制台看日志。 这就需要引入 CompletableFuture (异步转同步) 的机制。


一、 今日学习复盘：RPC 的“魔法时刻”
今天我们完成了从 “硬编码调用” 到 “动态代理调用” 的华丽转身。
1. 核心概念：动态代理 (Dynamic Proxy)
以前 (Day 1)：你需要手动造 RpcRequest 对象，像填表格一样一个个填（接口名、方法名...），非常麻烦且丑陋。
现在 (Day 2)：你只需要像调用本地方法一样调用接口 helloService.sayHello("...")。
原理：
我们利用 JDK 动态代理 (Proxy.newProxyInstance) 在内存中凭空生成了一个 HelloService 的**“傀儡对象”**。
这个傀儡没有任何业务逻辑，它的唯一作用就是把你的所有操作**“拦截”**下来，转发给 InvocationHandler（也就是我们写的 ClientProxy）。

2. 代码架构演进
我们修改了三个核心文件，它们的分工变得更加专业：
ClientProxy.java (新晋主角 - 经纪人)：
职责：实现了 InvocationHandler 接口。它是“拦截器”，负责将方法调用（Method Call）转换成数据对象（RpcRequest）。
关键点：它屏蔽了底层的网络细节，让调用者感觉不到网络的存在。
RpcClient.java (被改造 - 快递员)：
变化：从“只送特定包裹”变成了“通用快递员”。
职责：sendRequest(RpcRequest request)。给它什么请求，它就通过 Netty 发送什么请求。它不再关心业务逻辑。
TestClient.java (用户)：
变化：代码变得极度简洁。不再需要手动构建 Request，也不需要直接操作 Netty。
体验：clientProxy.getProxy(HelloService.class) 这一行代码，就是连接“本地”与“远程”的桥梁。



12-9:
RPC 项目中最核心、也是面试官最爱问的难点：异步转同步。

一、 核心逻辑：取餐号（Claim Check Pattern）
你现在的困境是：
Client (主线程)：把信扔进邮筒（Netty）就走了，没拿到回信。
Netty (子线程)：过了一会儿收到回信了，但它不知道这封信是谁寄的，也不知道该给谁。
解决方案：引入“取餐号”机制。
贴号 (Request ID)：主线程寄信前，在信封上写个唯一的号码（UUID），比如 "1001"。
存根 (Future)：主线程手里紧紧攥着一张写着 "1001" 的空白支票（CompletableFuture），坐在门口死等。
原样返回：服务端收到 "1001" 的信，处理完，在回信上也写上 "1001"。
兑现：Netty 收到 "1001" 的回信，大喊一声：“谁手里有 1001 的支票？”主线程听到了，把回信的内容填到支票上，任务完成。

二、 Step 1: 基础设施升级 (给信封加编号)
为了实现“对号入座”，Request 和 Response 必须带上 ID。
操作： 修改 rpc-common 模块下的 RpcRequest.java 和 RpcResponse.java，给它们都加上 requestId 字段。

三、 Step 2: 服务端配合 (抄写编号)
服务端必须很“懂事”，收到什么 ID，回信时必须把这个 ID 抄回去，否则客户端不认账。
操作： 修改 rpc-core 模块下 RpcServer.java 的 Handler 部分。

四、 Step 3: 客户端改造 (今天的重头戏)
我们要修改 rpc-core 下的 RpcClient.java。这里需要用到 CompletableFuture 和 ConcurrentHashMap。
逻辑预告 (注释驱动)：
// 1. 这是一个“全局信箱”，用来存放所有发出去了但还没收回来的请求。
//    Key 是请求 ID，Value 是那个“空白支票” (Future)。
private static final Map<String, CompletableFuture<RpcResponse>> PENDING_REQUESTS = new ConcurrentHashMap<>();

// 2. 发送逻辑 (sendRequest 方法)：
//    - 生成 UUID。
//    - 造一个 CompletableFuture，放进全局信箱。
//    - 发送请求。
//    - 阻塞等待 Future 有结果 (future.get)。

// 3. 接收逻辑 (Handler 的 channelRead0 方法)：
//    - 拿到响应里的 ID。
//    - 去全局信箱里把对应的 Future 找出来。
//    - 把响应塞进 Future 里 (future.complete)。

五、 Step 4: 修改 Proxy (把最后一块拼图补上)
现在 RpcClient.sendRequest 已经能返回 Object 结果了（不再是 null），我们需要修改 ClientProxy.java，把这个结果 return 出去。
修改 ClientProxy.java 的 invoke 方法：

今日任务： 按顺序执行这 4 步（Common -> Server -> Client -> Proxy）。 一旦 TestClient 能打印出结果，立刻 Commit + Push，然后结束今天的战斗！




















