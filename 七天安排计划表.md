### 📅 接下来的详细排期表

#### **Day 3（明天）：解决“发信无回” —— 异步转同步**

- **当前痛点**：`helloService.sayHello()` 返回 null，结果打印在控制台。
- **核心任务**：
  - 给 `RpcRequest` 加一个唯一 ID (`uuid`)。
  - 使用 **`CompletableFuture`** 机制。Client 发完消息后，用 `Map<requestId, Future>` 把它存起来，主线程挂起等待（`future.get()`）。
  - 当 Netty 收到 `RpcResponse` 后，根据 ID 找到那个 Future，把结果填进去，主线程瞬间被唤醒拿到结果。
- **面试价值**：这一天你能彻底搞懂 **Future 模式** 和 **多线程并发协作**。

#### **Day 4：解决“写死 IP” —— 引入注册中心 (Zookeeper 或 Nacos)**

- **当前痛点**：`new ClientProxy("127.0.0.1", 9000)`，地址是写死的。万一服务器换了 IP 怎么办？
- **核心任务**：
  - **Server 端**：启动时，自动把自己注册到 Zookeeper 上（比如 `/my-rpc/HelloService/192.168.1.5:9000`）。
  - **Client 端**：调用时，先去 Zookeeper 查“HelloService 在哪？”，拿到地址后再连接。
- **面试价值**：**分布式系统的核心——服务发现**。面试官必问 Zookeeper 的节点类型（临时节点 vs 持久节点）。

#### **Day 5：解决“只有一个服务员” —— 负载均衡 (Load Balance)**

- **当前痛点**：如果有 3 个服务器都提供了 `HelloService`，Client 该选谁？
- **核心任务**：
  - 实现策略接口 `LoadBalancer`。
  - 写 2-3 个策略：**随机 (Random)**、**轮询 (RoundRobin)**、**一致性 Hash (ConsistentHash)**。
- **面试价值**：**一致性 Hash** 是大厂面试超高频考点，你写在项目里，面试官肯定会问，问了你就能拿分。

#### **Day 6：解决“语言不通” —— 自定义序列化**

- **当前痛点**：我们现在用的是 Java 原生 `ObjectOutputStream`，效率低且只能给 Java 用。
- **核心任务**：
  - 把序列化逻辑抽取成一个接口 `Serializer`。
  - 引入 **Kryo** 或 **Hessian** 或 **Protobuf**（选一个实现即可），替换掉 Netty 自带的编解码器。
- **面试价值**：体现你对**性能优化**的追求。

#### **Day 7：解决“用起来麻烦” —— Spring 注解支持 (封装)**

- **当前痛点**：还要写 `server.register`，还要写 `clientProxy.getProxy`，太麻烦。
- **核心任务**：
  - 实现自定义注解 **`@RpcService`** (服务提供者用) 和 **`@RpcReference`** (消费者用)。
  - 利用 Spring 的 `BeanPostProcessor`，在 Spring 启动时自动扫描这些注解，自动干活。
- **面试价值**：**Spring 原理**的实战应用（IOC 容器的扩展点）。这一步做完，你的项目看起来就像真的一样了。

#### **Day 8+：锦上添花 (可选)**

- **心跳检测**：防止服务器挂了客户端不知道。
- **文档 & 压测**：写个好看的 README，用 JMeter 压测一下 QPS。